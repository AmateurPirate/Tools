import pandas as pd




# These objects contain all raw data pertaining to each "reach" event
class Reach(object):
    
    def __init__(self, mouseNum, cageNum, videoName, startFrame, endFrame, fps, deepLabCutFrameInfo):
        
        self.mouseNum = mouseNum
        self.cageNum = cageNum
        self.videoName = videoName
        self.startFrame = startFrame
        self.endFrame = endFrame
        self.fps = fps
        self.deepLabCutFrameInfo = deepLabCutFrameInfo




Dataframe = pd.read_hdf("outputDeepCut_resnet50_singlePelletMay08shuffle1_150000.h5")



# Extract reaching events from dataframe

# DeepLabCut output config
bp = 'pawCenter'
scorer = 'DeepCut_resnet50_singlePelletMay08shuffle1_150000'
# Going to hold our list of "reach" objects
reaches = []
# Loop temp variables 
searching_for_start_of_reach = True
threshold = 0.2
frameCounter = 0
start_reach_frame_number = -1
end_reach_frame_number = -1
frames_in_reach = []


# This loop extracts all the "reaching events" from a pandas dataframe that has been generated by DeepLabCut.
# It finds reaching events by examining the detection <likelihood> of a specified body part over time. If the detection likelihood
# of the specified body part remains above <threshold> for >=3 frames, then exactly 4 frames before the beginning of the <likelihood>
# spike will be considered the starting frame of the reaching event. The starting frame and all subsequent frame's information will be saved until the end of the reach is 
# detected. The end of reach frame is found when the <likelihood> of the specified bodypart has dipped below <threshold> for 15
# consecutive frames. Once the end is found, all meta information and the information for all frames spanning the reaching event are
# packaged into a <Reach> object and saved in a list. 
for index, row in Dataframe.iterrows():

    print(index)

    if searching_for_start_of_reach:
        
        if float(row[scorer][bp]['likelihood']) > threshold:
            
            frameCounter += 1

            # If 3 consecutive frames are detected where pawCenter detection confidence is
            # greater than <start_reach_threshold>, save the frame index where the detection confidence spike started.
            if frameCounter == 3:
            
                # Grab 4 frames BEFORE initial confidence spike
                frames_in_reach.append(Dataframe.iloc[[index - 6]]) 
                frames_in_reach.append(Dataframe.iloc[[index - 5]]) 
                frames_in_reach.append(Dataframe.iloc[[index - 4]]) 
                frames_in_reach.append(Dataframe.iloc[[index - 3]]) 
                frames_in_reach.append(Dataframe.iloc[[index - 2]])
                frames_in_reach.append(Dataframe.iloc[[index - 1]])
                frames_in_reach.append(Dataframe.iloc[[index]]) 
                start_reach_frame_number = index - 6
                frameCounter = 0
                searching_for_start_of_reach = False
                
        else:
            frameCounter = 0

    else:
        
        frames_in_reach.append(Dataframe.iloc[[index]])        
        
        if float(row[scorer][bp]['likelihood']) <= threshold:
            
            frameCounter += 1

            # If 3 consecutive frames are detected where pawCenter detection confidence is
            # less than <start_reach_threshold>, save the frame index where the detection confidence dip started.
            if frameCounter == 12:
                
                end_reach_frame_number = index - 1
                frameCounter = 0
                searching_for_start_of_reach = True
                
                # Create a reach object and reset all the temp variables used for this loop 
                reaches.append(Reach(1,1,"test", start_reach_frame_number, end_reach_frame_number, 161, frames_in_reach))
                frames_in_reach = []
                start_reach_frame_number = -1
                end_reach_frame_number = -1
                
        else:
            
            frameCounter = 0
            







# The block of code below calculates various things for each <Reach> object in the <reaches> list.
# It then writes that information to a csv file with 1 <Reach> per line.
outputfile = open('reaching_info.csv', 'w')
# Column headers for csv file
header = "reachNumber, mouseNumber, cageNumber, videoName, fps, startFrame, endFrame, reachDuration(s), reachDistance\n"
outputfile.write(header)

reachNum = 1
for reach in reaches:

    # Write meta information of reaching event to line.
    line = str(reachNum) + "," + str(reach.mouseNum) + "," + str(reach.cageNum) + "," + str(reach.videoName) + "," + str(reach.fps) + "," + str(reach.startFrame) + "," + str(reach.endFrame) + ","

    # Calculate duration of reach in seconds.
    # Note: This calculation is based on fps and can
    # can only be trusted as much as the fps of your video.
    reachDuration = float((reach.endFrame - reach.startFrame) / reach.fps)
    line += "%.2f" % reachDuration + ","


    # Find minX and maxX of paw during reach to calculate reaching distance
    minX = 640
    maxX = 0    
    for frame in reach.deepLabCutFrameInfo:
        
        pawX = float(frame[scorer]['pawCenter']['x'])
        
        if float(frame[scorer]['pawCenter']['likelihood']) > 0.4:
            if minX > pawX:
                minX = pawX
                
            if maxX < pawX:
                maxX = pawX
                
    reachDistance = maxX - minX
    line += "%.2f" % reachDistance + "\n"  


    reachNum += 1
    outputfile.write(line)
		








